---
title:  "[Algorithm] 19. 큐와 스택, 데크"
excerpt: "스택을 이용한 울타리 자르기 문제의 해법"

categories:
  - Algorithm
tags:
  - [algorithm]

toc: true
toc_sticky: true

date: 2022-03-30
last_modified_at: 2022-03-30
---
# 스택과 큐의 활용

### 예제: 스택을 이용한 울타리 자르기 문제의 해법

너비가 같은 N개의 나무 판자를 붙여 세운 울타리가 있다.

시간이 지남에 따라 판자들이 부러지거나 망가져 높이가 다 달라진 관계로 울타리를 통째로 교체하려고 한다.

이때 버리는 울타리의 일부를 직사각형으로 잘라내 재활용하고 싶다.

울타리를 구성하는 각 판자의 높이가 주어질 때, 잘라낼 수 있는 직사각형의 최대 크기를 계산하는 프로그램을 작성하라.

단, 직사각형을 비스듬히 잘라낼 수 없다.

판자의 너비는 모두 1이라고 가정한다.

분할 정복을 이용하여 울타리 자르기 문제를 더 효율적으로 풀려면, 스위핑 알고리즘과 스택을 결합하여 푼다.

분할 정복을 이용하면 O(NlgN) 이지만, 스위핑알고리즘과 스택을 사용하면 O(N) 시간에 동작한다.

i번 판자의 최대 사각형이란?

- i 번 판자를 완전히 포함하는 사각형 중 면적이 최대인 사각형

최대 사각형의 높이는 i번 판자와 항상 같다.

사각형의 왼쪽 끝과 오른쪽 끝은 i번 판자보다 낮은 판자들로 막혀 있다.

이 사각형을 막는 판자들의 번호를 각각 left[i], right[i] 라고 부른다.

ex) 

- h : 각 판자의 높이 배열
- left[i] : i 번째 판자의 최대 사각형의 왼쪽 끝
- right[i] : i 번쨰 판자의 최대 사각형의 오른쪽 끝

```cpp
h    = [ 3, 5, 6, 7, 5, 6, 2, 1] 
left = [-1, 1, 1, 1, 1, 1,-1 -1]
right =[ 1, 6, 6, 6, 6, 6, 7, 8]
```

최대 사각형의 넓이를 구하려면, (right[i] - left[i] - 1 ) * h[i] 로 계산한다.

모든 판자 i에 대해 최대 사각형 넓이를 구하고 그 중 최대치를 구하면 된다.

left[i], right[i] 를 상수 시간에 계산하라면, 다른 판자에 대해 계산한 정보를 재활용해야 한다.

## 스위핑 알고리즘의 설계

```cpp
// i = 0 일 때
left  = [ -1, ...
right = [  ?, ...

// i = 1
//// h[0] > h[1]
/**
 |
 | |  ...
 0 1 
*/
left =  [ -1, -1 ...
right = [  1,  ? ...
//// h[0] < h[1]
left =  [  -1, 0,...
right = [   ?, ? ...
//// h[0] = h[1]
//// h[0] > h[1] 경우와 동일하게 처리한다.

```

![image](https://user-images.githubusercontent.com/100340879/160730022-a4f47136-f162-4715-b682-f944ea6f4399.png)
